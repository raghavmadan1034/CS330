Part1  
------

Q1. If you manually run the testcase#1 without performing any modifications, the OS hangs. Explain why?
     
    Ans: The instruction pointer will not increment as we haven't implemented the div by zero exception handler.

Q2. After building gemOS for testcase#1 (manually), run `objdump -D user/init.o`, examine the assembly for main to 
    find the `idiv' instruction. Apart from the implicit "rax" register, which other register is used? 
    Which registers is used as the numerator and which register as the denominator?

	Ans: rcx -> denominator
	     rax/rdx -> numerator

Part 2
------

Q1. After building gemOS for testcase#2 (manually), run `objdump -D user/init.o`, examine the assembly for main to 
    find the `idiv' instruction. What is the length of the `idiv' instruction?

	Ans: 3

Q2. Can we use the register over-writing strategy for testcase2? why or why not?

	Ans: NO . The registers that are being over-written should not be used elsewhere for the stategy to work , which is not the case here.

Q3. Which memory does the `regs' argument to do_div_by_zero (in hack.c) point to (hint: check the os_rsp value in exec_ctx)?

	Ans: OS Stack


Part 3
------

Q1. Why testcase#2 should show the output 'Error...exiting'

	Ans: The address of a is not code segment adress.


Part 4
------
Q1. What all registers are changed in do_div_by_zero and why?

Ans: rax-> to store the return value 1
	rbp-> to return to previous frame
	rsp-> to maintain at the top of stack
	rip-> to jump back to previous function


Q2. In testcase #4 and #5, how many times the 'fact' function would return one? 

	Ans: 3 in testcase 4, 5 in testcase 5
